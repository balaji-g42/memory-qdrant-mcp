#!/usr/bin/env node

// Main entry point for MCP server
import "dotenv/config";

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

import { logMemory, queryMemory } from "./mcp_tools/memoryBankTools.js";
import { logDecision, logProgress } from "./mcp_tools/store.js";
import { summarizeText } from "./mcp_tools/summarizer.js";
import {
    getProductContext,
    updateProductContext,
    getActiveContext,
    updateActiveContext,
    logDecisionStructured,
    getDecisionsStructured,
    searchDecisionsFTSStructured,
    semanticSearchStructured,
    createKnowledgeLinkStructured,
    getKnowledgeLinksStructured,
    getContextHistoryStructured,
    batchLogMemoryStructured,
    batchQueryMemoryStructured,
    batchUpdateStructuredContextStructured,
    getSystemPatternsStructured,
    updateSystemPatternsStructured,
    searchSystemPatternsStructured,
    getProgressWithStatusStructured,
    updateProgressWithStatusStructured,
    searchProgressEntriesStructured,
    storeCustomDataStructured,
    getCustomDataStructured,
    queryCustomDataStructured,
    searchCustomDataStructured,
    updateCustomDataStructured,
    initializeWorkspaceStructured,
    syncMemoryStructured,
    exportMemoryToMarkdownStructured,
    importMemoryFromMarkdownStructured,
    analyzeConversationStructured
} from "./mcp_tools/contextTools.js";

// Log uncaught errors so startup failures are visible
process.on("unhandledRejection", (reason) => {
    console.error("UnhandledRejection:", reason);
});
process.on("uncaughtException", (err) => {
    console.error("UncaughtException:", err);
    process.exit(1);
});

// Create McpServer instance
const server = new McpServer({
    name: "memory-qdrant-mcp",
    version: "2.0.0",
});

// Register all tools using McpServer.registerTool()

// Basic memory operations
server.registerTool('log_memory', {
    description: "Log a memory entry to the vector database",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        memory_type: z.string().describe("Type of memory (e.g., productContext, activeContext)"),
        content: z.string().describe("Content to log"),
        top_level_id: z.string().optional().describe("Optional top level ID")
    })
}, async (params) => {
    const memoryId = await logMemory(
        params.project_name,
        params.memory_type,
        params.content,
        params.top_level_id
    );
    return {
        content: [{
            type: "text",
            text: `Memory logged with ID: ${memoryId}`
        }]
    };
});

server.registerTool('query_memory', {
    description: "Query memory entries from the vector database",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_text: z.string().describe("Query text"),
        memory_type: z.string().optional().describe("Optional memory type filter"),
        top_k: z.number().optional().default(3).describe("Number of results to return")
    })
}, async (params) => {
    const results = await queryMemory(
        params.project_name,
        params.query_text,
        params.memory_type,
        params.top_k
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

server.registerTool('log_decision', {
    description: "Log a decision entry",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        decision_text: z.string().describe("Decision text"),
        top_level_id: z.string().optional().describe("Optional top level ID")
    })
}, async (params) => {
    const decisionId = await logDecision(
        params.project_name,
        params.decision_text,
        params.top_level_id
    );
    return {
        content: [{
            type: "text",
            text: `Decision logged with ID: ${decisionId}`
        }]
    };
});

server.registerTool('log_progress', {
    description: "Log a progress entry",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        progress_text: z.string().describe("Progress text"),
        top_level_id: z.string().optional().describe("Optional top level ID")
    })
}, async (params) => {
    const progressId = await logProgress(
        params.project_name,
        params.progress_text,
        params.top_level_id
    );
    return {
        content: [{
            type: "text",
            text: `Progress logged with ID: ${progressId}`
        }]
    };
});

server.registerTool('summarize_text', {
    description: "Summarize the given text",
    inputSchema: z.object({
        text: z.string().describe("Text to summarize")
    })
}, async (params) => {
    const summary = await summarizeText(params.text);
    return {
        content: [{
            type: "text",
            text: summary
        }]
    };
});

server.registerTool('query_memory_summarized', {
    description: "Query memory entries and return summarized results to reduce token usage",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_text: z.string().describe("Query text"),
        memory_type: z.string().optional().describe("Optional memory type filter"),
        top_k: z.number().optional().default(3).describe("Number of results to return")
    })
}, async (params) => {
    const results = await queryMemory(
        params.project_name,
        params.query_text,
        params.memory_type,
        params.top_k
    );
    const resultsText = JSON.stringify(results, null, 2);
    const summary = await summarizeText(resultsText);
    return {
        content: [{
            type: "text",
            text: summary
        }]
    };
});

// Context management tools
server.registerTool('get_product_context', {
    description: "Get the product context for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project")
    })
}, async (params) => {
    const context = await getProductContext(params.project_name);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(context, null, 2)
        }]
    };
});

server.registerTool('update_product_context', {
    description: "Update the product context for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        content: z.record(z.any()).optional().describe("Full content to replace"),
        patch_content: z.record(z.any()).optional().describe("Partial content to merge")
    })
}, async (params) => {
    const resultId = await updateProductContext(
        params.project_name,
        params.content,
        params.patch_content
    );
    return {
        content: [{
            type: "text",
            text: `Product context updated with ID: ${resultId}`
        }]
    };
});

server.registerTool('get_active_context', {
    description: "Get the active context for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project")
    })
}, async (params) => {
    const context = await getActiveContext(params.project_name);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(context, null, 2)
        }]
    };
});

server.registerTool('update_active_context', {
    description: "Update the active context for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        content: z.record(z.any()).optional().describe("Full content to replace"),
        patch_content: z.record(z.any()).optional().describe("Partial content to merge")
    })
}, async (params) => {
    const resultId = await updateActiveContext(
        params.project_name,
        params.content,
        params.patch_content
    );
    return {
        content: [{
            type: "text",
            text: `Active context updated with ID: ${resultId}`
        }]
    };
});

server.registerTool('get_decisions', {
    description: "Get decisions for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        limit: z.number().optional().default(10).describe("Maximum number of decisions to return"),
        tags_filter_include_all: z.array(z.string()).optional().describe("Tags that must all be present"),
        tags_filter_include_any: z.array(z.string()).optional().describe("Tags where at least one must be present")
    })
}, async (params) => {
    const decisions = await getDecisionsStructured(
        params.project_name,
        params.limit,
        params.tags_filter_include_all,
        params.tags_filter_include_any
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(decisions, null, 2)
        }]
    };
});

server.registerTool('search_decisions_fts', {
    description: "Search decisions using full-text search",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_term: z.string().describe("Search query term"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const results = await searchDecisionsFTSStructured(
        params.project_name,
        params.query_term,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

server.registerTool('semantic_search', {
    description: "Perform semantic search across all memory types using embeddings",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_text: z.string().describe("Natural language query for semantic search"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return"),
        memory_types: z.array(z.string()).optional().describe("Optional filter for specific memory types")
    })
}, async (params) => {
    const results = await semanticSearchStructured(
        params.project_name,
        params.query_text,
        params.limit,
        params.memory_types
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

// Knowledge graph tools
server.registerTool('create_knowledge_link', {
    description: "Create a knowledge link between two memory entities",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        source_id: z.string().describe("ID of the source entity"),
        target_id: z.string().describe("ID of the target entity"),
        link_type: z.string().describe("Type of relationship (e.g., 'related_to', 'depends_on', 'implements')"),
        metadata: z.record(z.any()).optional().describe("Optional metadata for the link")
    })
}, async (params) => {
    const linkId = await createKnowledgeLinkStructured(
        params.project_name,
        params.source_id,
        params.target_id,
        params.link_type,
        params.metadata
    );
    return {
        content: [{
            type: "text",
            text: `Knowledge link created with ID: ${linkId}`
        }]
    };
});

server.registerTool('get_knowledge_links', {
    description: "Get knowledge links for an entity",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        entity_id: z.string().describe("ID of the entity to get links for"),
        link_type: z.string().optional().describe("Optional filter by link type"),
        direction: z.enum(['outgoing', 'incoming', 'both']).optional().default('both').describe("Direction of links to retrieve")
    })
}, async (params) => {
    const links = await getKnowledgeLinksStructured(
        params.project_name,
        params.entity_id,
        params.link_type,
        params.direction
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(links, null, 2)
        }]
    };
});

server.registerTool('get_context_history', {
    description: "Get the history of context changes for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        context_type: z.enum(['product', 'active']).describe("Type of context to get history for"),
        limit: z.number().optional().default(10).describe("Maximum number of history entries to return")
    })
}, async (params) => {
    const history = await getContextHistoryStructured(
        params.project_name,
        params.context_type,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(history, null, 2)
        }]
    };
});

// Batch operations
server.registerTool('batch_log_memory', {
    description: "Log multiple memory entries at once",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        entries: z.array(z.object({
            memory_type: z.string(),
            content: z.string(),
            top_level_id: z.string().optional()
        })).describe("Array of memory entries to log")
    })
}, async (params) => {
    const ids = await batchLogMemoryStructured(params.project_name, params.entries);
    return {
        content: [{
            type: "text",
            text: `${ids.length} memory entries logged: ${JSON.stringify(ids, null, 2)}`
        }]
    };
});

server.registerTool('batch_query_memory', {
    description: "Query multiple memory entries at once",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        queries: z.array(z.object({
            query_text: z.string(),
            memory_type: z.string().optional(),
            top_k: z.number().optional()
        })).describe("Array of queries to execute")
    })
}, async (params) => {
    const results = await batchQueryMemoryStructured(params.project_name, params.queries);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

server.registerTool('batch_update_context', {
    description: "Update multiple context types at once",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        updates: z.array(z.object({
            context_type: z.enum(['product', 'active']),
            content: z.record(z.any()).optional(),
            patch_content: z.record(z.any()).optional()
        })).describe("Array of context updates")
    })
}, async (params) => {
    const results = await batchUpdateStructuredContextStructured(params.project_name, params.updates);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

// System patterns tools
server.registerTool('get_system_patterns', {
    description: "Get system patterns for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        pattern_type: z.string().optional().describe("Optional filter by pattern type")
    })
}, async (params) => {
    const patterns = await getSystemPatternsStructured(params.project_name, params.pattern_type);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(patterns, null, 2)
        }]
    };
});

server.registerTool('update_system_patterns', {
    description: "Update system patterns for a project",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        pattern_type: z.string().describe("Type of pattern to update"),
        content: z.record(z.any()).describe("Pattern content")
    })
}, async (params) => {
    const resultId = await updateSystemPatternsStructured(
        params.project_name,
        params.pattern_type,
        params.content
    );
    return {
        content: [{
            type: "text",
            text: `System pattern updated with ID: ${resultId}`
        }]
    };
});

server.registerTool('search_system_patterns', {
    description: "Search system patterns using full-text search",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_term: z.string().describe("Search query term"),
        pattern_type: z.string().optional().describe("Optional filter by pattern type"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const results = await searchSystemPatternsStructured(
        params.project_name,
        params.query_term,
        params.pattern_type,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

// Progress tracking with status
server.registerTool('get_progress_with_status', {
    description: "Get progress entries filtered by status",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        status: z.enum(['not_started', 'in_progress', 'completed', 'blocked']).optional().describe("Optional filter by status"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const progress = await getProgressWithStatusStructured(
        params.project_name,
        params.status,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(progress, null, 2)
        }]
    };
});

server.registerTool('update_progress_with_status', {
    description: "Update progress entry with status",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        progress_id: z.string().describe("ID of the progress entry to update"),
        status: z.enum(['not_started', 'in_progress', 'completed', 'blocked']).describe("New status"),
        notes: z.string().optional().describe("Optional notes about the status change")
    })
}, async (params) => {
    const resultId = await updateProgressWithStatusStructured(
        params.project_name,
        params.progress_id,
        params.status,
        params.notes
    );
    return {
        content: [{
            type: "text",
            text: `Progress status updated with ID: ${resultId}`
        }]
    };
});

server.registerTool('search_progress_entries', {
    description: "Search progress entries using full-text search",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        query_term: z.string().describe("Search query term"),
        status: z.enum(['not_started', 'in_progress', 'completed', 'blocked']).optional().describe("Optional filter by status"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const results = await searchProgressEntriesStructured(
        params.project_name,
        params.query_term,
        params.status,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

// Custom data storage
server.registerTool('store_custom_data', {
    description: "Store custom data in the vector database",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        data_type: z.string().describe("Type of custom data being stored"),
        content: z.record(z.any()).describe("The custom data content"),
        metadata: z.record(z.any()).optional().describe("Optional metadata")
    })
}, async (params) => {
    const dataId = await storeCustomDataStructured(
        params.project_name,
        params.data_type,
        params.content,
        params.metadata
    );
    return {
        content: [{
            type: "text",
            text: `Custom data stored with ID: ${dataId}`
        }]
    };
});

server.registerTool('get_custom_data', {
    description: "Get custom data by type",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        data_type: z.string().describe("Type of custom data to retrieve"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const data = await getCustomDataStructured(
        params.project_name,
        params.data_type,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(data, null, 2)
        }]
    };
});

server.registerTool('query_custom_data', {
    description: "Query custom data using semantic search",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        data_type: z.string().describe("Type of custom data to query"),
        query_text: z.string().describe("Query text for semantic search"),
        top_k: z.number().optional().default(5).describe("Number of results to return")
    })
}, async (params) => {
    const results = await queryCustomDataStructured(
        params.project_name,
        params.data_type,
        params.query_text,
        params.top_k
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

server.registerTool('search_custom_data', {
    description: "Search custom data using full-text search",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        data_type: z.string().describe("Type of custom data to search"),
        query_term: z.string().describe("Search query term"),
        limit: z.number().optional().default(10).describe("Maximum number of results to return")
    })
}, async (params) => {
    const results = await searchCustomDataStructured(
        params.project_name,
        params.data_type,
        params.query_term,
        params.limit
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(results, null, 2)
        }]
    };
});

server.registerTool('update_custom_data', {
    description: "Update existing custom data entry",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        data_id: z.string().describe("ID of the custom data entry to update"),
        content: z.record(z.any()).describe("Updated content"),
        metadata: z.record(z.any()).optional().describe("Optional updated metadata")
    })
}, async (params) => {
    const resultId = await updateCustomDataStructured(
        params.project_name,
        params.data_id,
        params.content,
        params.metadata
    );
    return {
        content: [{
            type: "text",
            text: `Custom data updated with ID: ${resultId}`
        }]
    };
});

// Workspace and memory management tools
server.registerTool('initialize_workspace', {
    description: "Initialize a new workspace/project in the memory system",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project to initialize"),
        metadata: z.record(z.any()).optional().describe("Optional metadata for the workspace")
    })
}, async (params) => {
    const result = await initializeWorkspaceStructured(params.project_name, params.metadata);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(result, null, 2)
        }]
    };
});

server.registerTool('sync_memory', {
    description: "Synchronize memory between local and remote stores",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        direction: z.enum(['push', 'pull', 'both']).optional().default('both').describe("Direction of sync")
    })
}, async (params) => {
    const result = await syncMemoryStructured(params.project_name, params.direction);
    return {
        content: [{
            type: "text",
            text: JSON.stringify(result, null, 2)
        }]
    };
});

server.registerTool('export_memory_to_markdown', {
    description: "Export project memory to Markdown format",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        include_types: z.array(z.string()).optional().describe("Optional filter for specific memory types to export")
    })
}, async (params) => {
    const markdown = await exportMemoryToMarkdownStructured(
        params.project_name,
        params.include_types
    );
    return {
        content: [{
            type: "text",
            text: markdown
        }]
    };
});

server.registerTool('import_memory_from_markdown', {
    description: "Import memory from Markdown format",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        markdown_content: z.string().describe("Markdown content to import")
    })
}, async (params) => {
    const result = await importMemoryFromMarkdownStructured(
        params.project_name,
        params.markdown_content
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(result, null, 2)
        }]
    };
});

server.registerTool('analyze_conversation', {
    description: "Analyze a conversation and extract key insights, decisions, and action items",
    inputSchema: z.object({
        project_name: z.string().describe("Name of the project"),
        conversation_text: z.string().describe("The conversation text to analyze")
    })
}, async (params) => {
    const analysis = await analyzeConversationStructured(
        params.project_name,
        params.conversation_text
    );
    return {
        content: [{
            type: "text",
            text: JSON.stringify(analysis, null, 2)
        }]
    };
});

// The tools array and handlers have been replaced with registerTool() calls above
    {
        name: "log_memory",
        description: "Log a memory entry to the vector database",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                memory_type: { type: "string", description: "Type of memory (e.g., productContext, activeContext)" },
                content: { type: "string", description: "Content to log" },
                top_level_id: { type: "string", description: "Optional top level ID" }
            },
            required: ["project_name", "memory_type", "content"]
        }
    },
    {
        name: "query_memory",
        description: "Query memory entries from the vector database",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Query text" },
                memory_type: { type: "string", description: "Optional memory type filter" },
                top_k: { type: "number", description: "Number of results to return", default: 3 }
            },
            required: ["project_name", "query_text"]
        }
    },
    {
        name: "log_decision",
        description: "Log a decision entry",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                decision_text: { type: "string", description: "Decision text" },
                top_level_id: { type: "string", description: "Optional top level ID" }
            },
            required: ["project_name", "decision_text"]
        }
    },
    {
        name: "log_progress",
        description: "Log a progress entry",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                progress_text: { type: "string", description: "Progress text" },
                top_level_id: { type: "string", description: "Optional top level ID" }
            },
            required: ["project_name", "progress_text"]
        }
    },
    {
        name: "summarize_text",
        description: "Summarize the given text",
        inputSchema: {
            type: "object",
            properties: {
                text: { type: "string", description: "Text to summarize" }
            },
            required: ["text"]
        }
    },
    {
        name: "query_memory_summarized",
        description: "Query memory entries and return summarized results to reduce token usage",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Query text" },
                memory_type: { type: "string", description: "Optional memory type filter" },
                top_k: { type: "number", description: "Number of results to return", default: 3 }
            },
            required: ["project_name", "query_text"]
        }
    },
    {
        name: "get_product_context",
        description: "Get the product context for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "update_product_context",
        description: "Update the product context for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                content: { type: "object", description: "Full content to replace" },
                patch_content: { type: "object", description: "Partial content to merge" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "get_active_context",
        description: "Get the active context for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "update_active_context",
        description: "Update the active context for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                content: { type: "object", description: "Full content to replace" },
                patch_content: { type: "object", description: "Partial content to merge" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "get_decisions",
        description: "Get decisions for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                limit: { type: "number", description: "Maximum number of decisions to return", default: 10 },
                tags_filter_include_all: { type: "array", items: { type: "string" }, description: "Tags that must all be present" },
                tags_filter_include_any: { type: "array", items: { type: "string" }, description: "Tags where at least one must be present" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "search_decisions_fts",
        description: "Search decisions using full-text search",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_term: { type: "string", description: "Search query term" },
                limit: { type: "number", description: "Maximum number of results to return", default: 10 }
            },
            required: ["project_name", "query_term"]
        }
    },
    {
        name: "semantic_search",
        description: "Perform semantic search across all memory types using embeddings",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Natural language query for semantic search" },
                limit: { type: "number", description: "Maximum number of results to return", default: 10 },
                memory_types: { type: "array", items: { type: "string" }, description: "Optional filter for specific memory types" }
            },
            required: ["project_name", "query_text"]
        }
    },
    // Knowledge graph tools
    {
        name: "create_knowledge_link",
        description: "Create a knowledge link between two memory entities",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                source_id: { type: "string", description: "ID of the source entity" },
                target_id: { type: "string", description: "ID of the target entity" },
                link_type: { type: "string", description: "Type of relationship (e.g., 'related_to', 'depends_on', 'implements')" },
                description: { type: "string", description: "Optional description of the relationship" }
            },
            required: ["project_name", "source_id", "target_id", "link_type"]
        }
    },
    {
        name: "get_knowledge_links",
        description: "Get knowledge links for a specific entity",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                entity_id: { type: "string", description: "ID of the entity to get links for" },
                link_type: { type: "string", description: "Optional filter for specific link types" },
                direction: { type: "string", enum: ["incoming", "outgoing", "both"], description: "Direction of links to retrieve", default: "both" }
            },
            required: ["project_name", "entity_id"]
        }
    },
    {
        name: "get_context_history",
        description: "Get history of changes for a context type",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                context_type: { type: "string", description: "Type of context (e.g., 'productContext', 'activeContext')" },
                limit: { type: "number", description: "Maximum number of history entries to return", default: 10 }
            },
            required: ["project_name", "context_type"]
        }
    },
    // Batch operations
    {
        name: "batch_log_memory",
        description: "Log multiple memory entries in a single operation",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                entries: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            memoryType: { type: "string", enum: ["productContext", "activeContext", "systemPatterns", "decisionLog", "progress", "contextHistory", "customData"] },
                            content: { type: "string" },
                            topLevelId: { type: "string" }
                        },
                        required: ["memoryType", "content"]
                    }
                }
            },
            required: ["project_name", "entries"]
        }
    },
    {
        name: "batch_query_memory",
        description: "Perform multiple memory queries in a single operation",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                queries: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            queryText: { type: "string" },
                            memoryType: { type: "string" },
                            topK: { type: "number", default: 5 }
                        },
                        required: ["queryText"]
                    }
                }
            },
            required: ["project_name", "queries"]
        }
    },
    {
        name: "batch_update_context",
        description: "Update multiple structured contexts in a single operation",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                updates: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            contextType: { type: "string", enum: ["productContext", "activeContext"] },
                            patchContent: { type: "object" }
                        },
                        required: ["contextType", "patchContent"]
                    }
                }
            },
            required: ["project_name", "updates"]
        }
    },
    // System patterns
    {
        name: "get_system_patterns",
        description: "Get system patterns and conventions for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                limit: { type: "number", description: "Maximum number of patterns to return", default: 50 }
            },
            required: ["project_name"]
        }
    },
    {
        name: "update_system_patterns",
        description: "Add or update system patterns and conventions for a project",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                patterns: { type: "array", items: { type: "string" }, description: "Array of pattern strings to add/update" }
            },
            required: ["project_name", "patterns"]
        }
    },
    {
        name: "search_system_patterns",
        description: "Search system patterns using semantic search",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Natural language query for finding relevant patterns" },
                limit: { type: "number", description: "Maximum number of results to return", default: 10 }
            },
            required: ["project_name", "query_text"]
        }
    },
    // Progress tracking
    {
        name: "get_progress_with_status",
        description: "Get progress entries with status information",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                status: { type: "string", enum: ["pending", "in_progress", "completed", "blocked"], description: "Optional status filter" },
                limit: { type: "number", description: "Maximum number of entries to return", default: 50 }
            },
            required: ["project_name"]
        }
    },
    {
        name: "update_progress_with_status",
        description: "Update progress with status tracking",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                content: { type: "string", description: "Progress content" },
                status: { type: "string", enum: ["pending", "in_progress", "completed", "blocked"], default: "in_progress" },
                category: { type: "string", description: "Category of the progress item", default: "general" },
                priority: { type: "string", enum: ["low", "medium", "high", "critical"], default: "medium" }
            },
            required: ["project_name", "content"]
        }
    },
    {
        name: "search_progress_entries",
        description: "Search progress entries using semantic search",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Natural language query for finding relevant progress entries" },
                status: { type: "string", enum: ["pending", "in_progress", "completed", "blocked"], description: "Optional status filter" },
                limit: { type: "number", description: "Maximum number of results to return", default: 10 }
            },
            required: ["project_name", "query_text"]
        }
    },
    // Custom data storage
    {
        name: "store_custom_data",
        description: "Store custom data with metadata",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                data: { description: "The custom data to store (any JSON-serializable value)" },
                data_type: { type: "string", description: "Type/category of the custom data" },
                metadata: { type: "object", description: "Additional metadata for the data" }
            },
            required: ["project_name", "data", "data_type"]
        }
    },
    {
        name: "get_custom_data",
        description: "Get custom data by ID",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                data_id: { type: "string", description: "ID of the custom data to retrieve" }
            },
            required: ["project_name", "data_id"]
        }
    },
    {
        name: "query_custom_data",
        description: "Query custom data with filters",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                data_type: { type: "string", description: "Optional data type filter" },
                metadata_filter: { type: "object", description: "Optional metadata filters" },
                limit: { type: "number", description: "Maximum number of results to return", default: 50 }
            },
            required: ["project_name"]
        }
    },
    {
        name: "search_custom_data",
        description: "Search custom data using semantic search",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                query_text: { type: "string", description: "Natural language query for finding relevant custom data" },
                data_type: { type: "string", description: "Optional data type filter" },
                limit: { type: "number", description: "Maximum number of results to return", default: 10 }
            },
            required: ["project_name", "query_text"]
        }
    },
    {
        name: "update_custom_data",
        description: "Update existing custom data",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                data_id: { type: "string", description: "ID of the data to update" },
                data: { description: "New data to store" },
                metadata: { type: "object", description: "Updated metadata" }
            },
            required: ["project_name", "data_id", "data"]
        }
    },
    // Workspace initialization
    {
        name: "initialize_workspace",
        description: "Initialize workspace and detect project structure",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                workspace_info: {
                    type: "object",
                    properties: {
                        files: { type: "array", items: { type: "string" } },
                        directories: { type: "array", items: { type: "string" } }
                    }
                }
            },
            required: ["project_name"]
        }
    },
    // Memory sync
    {
        name: "sync_memory",
        description: "Sync memory with external sources (proactive logging)",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                sync_sources: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            name: { type: "string" },
                            type: { type: "string" },
                            config: { type: "object" }
                        },
                        required: ["name", "type"]
                    }
                }
            },
            required: ["project_name"]
        }
    },
    // Import/Export
    {
        name: "export_memory_to_markdown",
        description: "Export memory data to markdown format",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                memory_types: { type: "array", items: { type: "string" }, description: "Types of memory to export (optional - exports all if not specified)" }
            },
            required: ["project_name"]
        }
    },
    {
        name: "import_memory_from_markdown",
        description: "Import memory data from markdown",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                markdown_content: { type: "string", description: "Markdown content to import" }
            },
            required: ["project_name", "markdown_content"]
        }
    },
    // Conversation analysis
    {
        name: "analyze_conversation",
        description: "Analyze conversation and automatically log relevant information",
        inputSchema: {
            type: "object",
            properties: {
                project_name: { type: "string", description: "Name of the project" },
                conversation_text: { type: "string", description: "Conversation text to analyze" },
                metadata: {
                    type: "object",
                    properties: {
                        conversationId: { type: "string" },
                        participants: { type: "array", items: { type: "string" } },
                        source: { type: "string" }
                    }
                }
            },
            required: ["project_name", "conversation_text"]
        }
    }
];

// List tools handler
server.setRequestHandler(ListToolsRequestSchema, async () => {
    return { tools };
});

// Call tool handler
server.setRequestHandler(CallToolRequestSchema, async (request) => {
    const { name, arguments: args } = request.params;

    try {
        switch (name) {
            case "log_memory": {
                const memoryId = await logMemory(
                    args.project_name as string,
                    args.memory_type as string,
                    args.content as string,
                    args.top_level_id as string | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Memory logged with ID: ${memoryId}`
                    }]
                };
            }

            case "query_memory": {
                const results = await queryMemory(
                    args.project_name as string,
                    args.query_text as string,
                    args.memory_type as string | undefined,
                    args.top_k as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "log_decision": {
                const decisionId = await logDecision(
                    args.project_name as string,
                    args.decision_text as string,
                    args.top_level_id as string | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Decision logged with ID: ${decisionId}`
                    }]
                };
            }

            case "log_progress": {
                const progressId = await logProgress(
                    args.project_name as string,
                    args.progress_text as string,
                    args.top_level_id as string | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Progress logged with ID: ${progressId}`
                    }]
                };
            }

            case "summarize_text": {
                const summary = await summarizeText(args.text as string);
                return {
                    content: [{
                        type: "text",
                        text: summary
                    }]
                };
            }

            case "query_memory_summarized": {
                const results = await queryMemory(
                    args.project_name as string,
                    args.query_text as string,
                    args.memory_type as string | undefined,
                    args.top_k as number | undefined
                );
                const resultsText = JSON.stringify(results, null, 2);
                const summary = await summarizeText(resultsText);
                return {
                    content: [{
                        type: "text",
                        text: summary
                    }]
                };
            }

            case "get_product_context": {
                const context = await getProductContext(args.project_name as string);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(context, null, 2)
                    }]
                };
            }

            case "update_product_context": {
                const resultId = await updateProductContext(
                    args.project_name as string,
                    args.content as Record<string, any> | undefined,
                    args.patch_content as Record<string, any> | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Product context updated with ID: ${resultId}`
                    }]
                };
            }

            case "get_active_context": {
                const context = await getActiveContext(args.project_name as string);
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(context, null, 2)
                    }]
                };
            }

            case "update_active_context": {
                const resultId = await updateActiveContext(
                    args.project_name as string,
                    args.content as Record<string, any> | undefined,
                    args.patch_content as Record<string, any> | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Active context updated with ID: ${resultId}`
                    }]
                };
            }

            case "get_decisions": {
                const decisions = await getDecisionsStructured(
                    args.project_name as string,
                    args.limit as number | undefined,
                    args.tags_filter_include_all as string[] | undefined,
                    args.tags_filter_include_any as string[] | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(decisions, null, 2)
                    }]
                };
            }

            case "search_decisions_fts": {
                const results = await searchDecisionsFTSStructured(
                    args.project_name as string,
                    args.query_term as string,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "semantic_search": {
                const results = await semanticSearchStructured(
                    args.project_name as string,
                    args.query_text as string,
                    args.limit as number | undefined,
                    args.memory_types as string[] | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "create_knowledge_link": {
                const linkId = await createKnowledgeLinkStructured(
                    args.project_name as string,
                    args.source_id as string,
                    args.target_id as string,
                    args.link_type as string,
                    args.description as string | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Knowledge link created with ID: ${linkId}`
                    }]
                };
            }

            case "get_knowledge_links": {
                const links = await getKnowledgeLinksStructured(
                    args.project_name as string,
                    args.entity_id as string,
                    args.link_type as string | undefined,
                    args.direction as "incoming" | "outgoing" | "both" | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(links, null, 2)
                    }]
                };
            }

            case "get_context_history": {
                const history = await getContextHistoryStructured(
                    args.project_name as string,
                    args.context_type as string,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(history, null, 2)
                    }]
                };
            }

            case "batch_log_memory": {
                const ids = await batchLogMemoryStructured(
                    args.project_name as string,
                    args.entries as any[]
                );
                return {
                    content: [{
                        type: "text",
                        text: `Batch logged ${ids.length} entries with IDs: ${ids.join(", ")}`
                    }]
                };
            }

            case "batch_query_memory": {
                const results = await batchQueryMemoryStructured(
                    args.project_name as string,
                    args.queries as any[]
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "batch_update_context": {
                const ids = await batchUpdateStructuredContextStructured(
                    args.project_name as string,
                    args.updates as any[]
                );
                return {
                    content: [{
                        type: "text",
                        text: `Batch updated ${ids.length} contexts with IDs: ${ids.join(", ")}`
                    }]
                };
            }

            case "get_system_patterns": {
                const patterns = await getSystemPatternsStructured(
                    args.project_name as string,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(patterns, null, 2)
                    }]
                };
            }

            case "update_system_patterns": {
                const ids = await updateSystemPatternsStructured(
                    args.project_name as string,
                    args.patterns as string[]
                );
                return {
                    content: [{
                        type: "text",
                        text: `Updated ${ids.length} system patterns with IDs: ${ids.join(", ")}`
                    }]
                };
            }

            case "search_system_patterns": {
                const results = await searchSystemPatternsStructured(
                    args.project_name as string,
                    args.query_text as string,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "get_progress_with_status": {
                const progress = await getProgressWithStatusStructured(
                    args.project_name as string,
                    args.status as any,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(progress, null, 2)
                    }]
                };
            }

            case "update_progress_with_status": {
                const progressId = await updateProgressWithStatusStructured(
                    args.project_name as string,
                    args.content as string,
                    args.status as any,
                    args.category as string | undefined,
                    args.priority as any
                );
                return {
                    content: [{
                        type: "text",
                        text: `Progress updated with ID: ${progressId}`
                    }]
                };
            }

            case "search_progress_entries": {
                const results = await searchProgressEntriesStructured(
                    args.project_name as string,
                    args.query_text as string,
                    args.status as any,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "store_custom_data": {
                const dataId = await storeCustomDataStructured(
                    args.project_name as string,
                    args.data,
                    args.data_type as string,
                    args.metadata as Record<string, any> | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: `Custom data stored with ID: ${dataId}`
                    }]
                };
            }

            case "get_custom_data": {
                const data = await getCustomDataStructured(
                    args.project_name as string,
                    args.data_id as string
                );
                return {
                    content: [{
                        type: "text",
                        text: data ? JSON.stringify(data, null, 2) : "Custom data not found"
                    }]
                };
            }

            case "query_custom_data": {
                const results = await queryCustomDataStructured(
                    args.project_name as string,
                    args.data_type as string | undefined,
                    args.metadata_filter as Record<string, any> | undefined,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "search_custom_data": {
                const results = await searchCustomDataStructured(
                    args.project_name as string,
                    args.query_text as string,
                    args.data_type as string | undefined,
                    args.limit as number | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(results, null, 2)
                    }]
                };
            }

            case "update_custom_data": {
                const success = await updateCustomDataStructured(
                    args.project_name as string,
                    args.data_id as string,
                    args.data,
                    args.metadata as Record<string, any> | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: success ? "Custom data updated successfully" : "Failed to update custom data"
                    }]
                };
            }

            case "initialize_workspace": {
                const result = await initializeWorkspaceStructured(
                    args.project_name as string,
                    args.workspace_info as any
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(result, null, 2)
                    }]
                };
            }

            case "sync_memory": {
                const result = await syncMemoryStructured(
                    args.project_name as string,
                    args.sync_sources as any[]
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(result, null, 2)
                    }]
                };
            }

            case "export_memory_to_markdown": {
                const markdown = await exportMemoryToMarkdownStructured(
                    args.project_name as string,
                    args.memory_types as string[] | undefined
                );
                return {
                    content: [{
                        type: "text",
                        text: markdown
                    }]
                };
            }

            case "import_memory_from_markdown": {
                const result = await importMemoryFromMarkdownStructured(
                    args.project_name as string,
                    args.markdown_content as string
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(result, null, 2)
                    }]
                };
            }

            case "analyze_conversation": {
                const result = await analyzeConversationStructured(
                    args.project_name as string,
                    args.conversation_text as string,
                    args.metadata as any
                );
                return {
                    content: [{
                        type: "text",
                        text: JSON.stringify(result, null, 2)
                    }]
                };
            }

            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    } catch (error) {
        const err = error as Error;
        return {
            content: [{
                type: "text",
                text: `Error: ${err.message}`
            }],
            isError: true
        };
    }
});

async function main() {
    const transport = new StdioServerTransport();

    // Add error handling and logging for connection
    try {
        await server.connect(transport);
        console.error("Memory Qdrant MCP server running on stdio");
    } catch (error) {
        const err = error as Error;
        console.error("Error connecting server:", err.stack || err);
        process.exit(1);
    }
}

main().catch((error) => {
    const err = error as Error;
    console.error("Fatal error in main():", err.stack || err);
    process.exit(1);
});
